# 2. RxJava를 사용하는 데 필요한 배경 지식
## 2.1. 람다식

람다식은 자바 8에서 도입한 표현식

람다식을 사용하지 않아도 RxJava를 구현할 수 있지만  RxJava가 람다식으로 구현하는 것을 가정해 개발했기 때문에 람다식 사용하면 개발 효율이 높아진다.

람다식이 자바8부터 도입된거라 이전 자바 버전에서 람다식을 사용할 수 없다.

하지만 Retrolambda 백포트 라이브러리 사용하면 8 이전 버전에서 사용할 수 있다.

- 백포트 : 새로운 버전의 기능으로 이전버전에서도 사용할 수 있게하는 라이브러리

람다식은 함수형 인터페이스 구현에 필요한 최소 정보만을 구현할 수 있게 함 -> 메서드 인자,처리 내용만 필요

### 2.1.1 함수형 인터페이스

함수형 인터페이스 : 구현해야 하는 메서드가 하나뿐인 거. Comparator도 인터페이스

- 인자 유무, 타입
- 반환 타입 유무, 타입

RxJava는 자바 6이사 지원 -> 8 이후에 새로 추가된 함수형 인터페이스는 RxJava에서 사용 할 수 없음

- [ ] 8 이후에 새로 추가된 함수형 인터페이스

RxJava에서 독자적으로 준비한 함수형 인터페이스 제공 (io.reactive.functions 패키지)

많은 메서드가 이 함수형 인터페이스들을 인자로 받음

- Function/Predicate : 인자 O , 반환값 O
- BooleanSupplier : 인자 X, 반환값 O
- Action/Consumer : 반환값 X
- Cancellable : Action과 동일하나 실행 의미가 다른 인터페이스

RxJava에서 제공하는 함수형 인터페이스 메서드들은 예외를 던지게끔 선언되어있다

<-> 자바 표준 함수형 인터페이스는 예외를 못던짐

예외 발생시, 함수형 인터페이스의 호출자에서 잡혀 소비자에게 전달된다.

#### Function/Predicate

인자와 반환값이 있는 함수형 인터페이스

|        | Function | Predicate |
| ------ | -------- | --------- |
| 반환값 | 제한 X   | Boolean   |

Function은 반환값에 제한에 없는 것을 보아 데이터를 전달받아 행당 데이터로 무언가 생성 처리하는 것을 예상할 수 있음

Predicate는 반환값이 Boolean인 것을 보아 데이터를 받아 해당 데이터로 어떤 결정을 한다고 볼 수 있음

##### Function 함수형 인터페이스 목록

- Function<T,R>
- BiFunction<T1,T2,R>
- Function3<T1,T2,T3,R> ~ Function9<T1,T2,...,T9,R>
- intFunction<T>

##### Predicate 함수형 인터페이스 목록

- Predicate<T>
- BiPredicate<T1,T2>

#### BooleanSupplier

인자 없이 boolean 반환하는 메서드

일반적으로 Supplier이름이 붙는 함수형 인터페이스는 인자없이 다양한 타입의 값을 반환하는 메서드가 있지만 RxJava에서는 boolean 값을 반환하는 BooleanSupplier만 제공

- [ ] 다른 Supplier?
- [ ] 그럼 BooleanSupplier역할은...?

#### Action/Consumer

반환값이 없는 메서드. 즉, 어떤 부가 작용이 발생하는 메서드가 있는 함수형 인터페이스

|      | Action | Consumer |
| ---- | ------ | -------- |
| 인자 | 없음   | 있음     |
| 반환 | 없음   | 없음     |

##### Action 함수형 인터페이스 목록

- Action 
  - run()

##### Consumer 함수형 인터페이스 목록

- Consumer<T>
  - accept(T t)
- BiConsumer<T1,T2>
- LongConsumer

#### Cancellable

Action과 마찬가지로 인자와 반환이 없다.

어떤 취소 처리를 구현하는데 사용하는 인터페이스



### 2.1.2 람다식 문법

- 간결하게 구현 할 수 있다 -> 코드가 간결해진다 -> 작성자의 의도가 명확해진다 & 가독성이 좋아진다.

```
# 생략 없는 람다식
(타입 인자,...) -> {
	//실행문
	return 반환값;
}

# 인자가 없을 때
()->{
	return 반환값;
}

# 인자값이 1개일때
data -> {
	return data * 10;
}

# 리턴문만으로 끝나는 경우
data -> data * 10
# 반환값이 없을 경우
data -> System.out.println(data)
```

### 2.1.3 람다식과 익명 클래스의 차이점

둘간의 차이점은 this가 가리키는 대상이다.

익명클래스의 this는 구현한 인터페이스의 인스턴스를 나타내고, 

람다식의 this는 람다식을 구현한 클래스의 인스턴스를 나타낸다.



## 2.2 비동기 처리

  비동기 처리 : 어떤 작업을 실행하는 동안에 해당 처리가 끝나기를 기다리지 않고 다른 작업을 시작할 수 있는 것을 말함

멀티스레딩 : 여러 개의 스레드로 작업을 처리 하는 것

싱글 스레드 : 순차적으로 작업을 실행

1개의 논리 프로세서에서 멀티 스레드 처리 

- 특정 작업을 도중에 중단하고 다른 작업을 하는 방식

- 네트워크 통신이나 DB 검색 등 대기하는 프로세스가 있을 때 대기할 필요가 없이 다른 작업을 처리하면 되기 때문에 싱글스레드보다 빨리 끝남
  - 싱글스레드의 경우에는 해당 프로세스가 끝날 때 까지 기다림

멀티프로세스에서 멀티스레드 작업 실행하면 성능 향상을 기대할 수 있다.



스레드 생성 작업 자체가 부하가 걸리는 작업이라 모든 상황에서 비동기 처리로 성능 향상 기대하기 어려움

- 예시 : 금방 끝나는 가벼운 작업 여러개 동시 실행할 때 각 작업 스레드를 생성하는 시간이 하나의 스레드에서 순서대로 작업을 실행하는 시간보다 오래 걸린다면 성능 저하로 이어진다.

실행 중인 스레드를 전환하는 것도 부하가 걸리는 작업이다.

- 실행 가능한 프로세서보다 많은 스레드가 생성될 때, 작업에 대기가 발생하지 않으면 스레드를 전환하는 만큼 부하가 발생하여 성능이 저하된다.



### 2.2.1 비동기 처리 시 주의할 점

#### 메모리와 캐시

<b>클래스 필드가 가리키는 값과 실제 메모리가 가리키는 값이 동일  하지 않을 수 있다는 점</b>

필드가 다루는 값은 메모리에서 캐시된 값으로, 여기에서 값 참조와 변경을 하고 적절한 시점에서 실제 메모리 값을 변경한다.

그래서 메모리 반영전이라면 캐시 값과 메모리 값은 다르게 된다.

캐시는 스레드별로 있어서 특정 스레드에서 필드에 접근해 값을 변경했을 때, 다른 스레드에서 해당 필드 참조하면 스레드가 가진 캐시의 이전 값을 참조하는 문제가 발생한다.

- 싱글 스레드의 경우 -> 같은 캐시를 바라보고 있어 문제가 없다
- 비동기 처리 (멀티 스레드)  -> 스레드 별로 캐시가 있어 필드 값이 바뀌어도 다를 수 있다. 

- 값을 캐시하는 이유 : 성능 향상을 위해(매번 메모리에 접근하는 것보다 캐기 값에 접근하는게 성능에 유리함)

#### 원자성

원자성 : 일련의 처리가 분할할 수 없게 돼 있는것

<b>비동기 처리시, 일련의 처리 흐름 중간에 다른 작업이 끼어들 가능성이 있는지 고려해야한다.</b>

비동기 처리에서 특정 메서드를 실행하는 동안 다른 작업이 실행되므로 필드에 접근하면 원자성이 깨실 수도 있다.

싱글스레드의 경우는 특정 메서드를 실행하는 동안 다른 프로세스들은 실행 되지 않으므로 원자성이 깨지지 않는다.

- volatile : 업데이트한 값은 반드시 메모리에 반영돼 다른 스레드에서 참조할 때 같은 값을 얻게 하는 제한자



### 2.2.2  비동기 처리 시 발생하는 문제에 대한 대응 방안

####  final 제한자와 불변 객체

비동기 처리시에 값이 변경되는 필드나 상태가 변경되는 객체를 다루면 제어가 어렵고 버그가 발생 할 수 있음

-> 해결 방법 : 변수 재할당이나 객체 상태를 변경하지 못하게 한다.

- 생성후 변하지 않는 변수나 객체라면 각 스레드에서 같은 객체와 같은 값을 참조
- 변경할 수 없으니 변수나 객체 값을 다른 스레드에서 바꿀 위험도 없음

변경하지 못하는 것은 비동기 처리와 RxJava가 다루는 데이터를 메서드 체인으로 전달하는 구조에서 중요함.

변경 못하게 하는 방법 

- 변수에는 final 제한자를 붙인다. -> 재할당 불가능, 변경 시도시에 컴파일 에러, 처음 값이 설정된 시점에 메모리에 반영되어 모든 스레드에서 같은 값을 참조



- 불변 객체 (immutable object) : 생성 후에 상태를 변경할 수 없는 객체
- 가변 객체(mutable object) : 상태 변경이 가능한 객체

불변 객체는 모든 필드에 final를 붙여 생성자만으로 상태를 설정할 수있게 해 객체 상태를 변경을 방지함

final을 붙인 필드가 Date같은 가변적인 객체같은 경우는 외부에서 접근을 못하게 하고 복사본을 전달한다.

클래스를 final로 선언하면 상속을 할 수 없다.-> 자식 클래스에 의해 불변객체가 가변객체로 바뀔 일은 없다.



#### 공유되는 가변 객체 다루기

기본적으로는 비동기 처리에는 불변객체를 사용해햐함

어쩔수 없는 경우 가변 객체를 다루어햐 할때도 있는데 그 때는 다음 문제를 반드시 해결해야함

- 메모리와 캐시
- 원자성

#### Volatile 제한자

최신 메모리 값을 가져오게 보장하는 제한자

volatile가 붙은 필드가 변경되면 메모리 값이 변경된다.

volatile은 최신 값을 얻을 수 있지만 원자성을 보장하지는 않음

-> volatile 붙은 변수에 업데이트 작업을 할때는 하나의 특정 스레드로만 업데이트하고 그 외 스레드는 참조만 하게 한다.



### 2.2.3 java.util.concurrent.atomic 패키지

원자성 : 일련의 동작을 외부에서 분할 할 수 없는 특성

#### synchronized 블록

자신의 스레드가 synchronized 블록 처리하는 중에 다른 스레드에서 해당 블록에 접근하는 것을 막는다.

블록 내 실행하는 처리가 완료될 때 까지 다른 스레드는 대기한다.

배타 제어 : 다른 스레드의 접근을 막는 것

배타제어를 바르게 사용하면 여러 필드를 가지고 있어도 일관성을 유지 할 수 있다.

synchronized 블록에서 나올 떄 값이 메모리에 업데이트돼 다음에 다른 스레드가 synchronized 에 들어갈 때 그 값이 메모리에서 반영되어있음 -> 메모리와 캐시에서 값 차이가 없기 때문에 atomicInteger 대신 int 써도 무방한다.

synchronized 는 다른 스레드를 기다리게 하므로, 과도한 synchronized  사용은 성능에 영향을 준다.

- 교착 상태(deadlock) : 각 스레드가 각 상대 락 객체의 해제를 기다리면서 처리를 진행하지 못하고 계속 기다리는 상태



### 2.2.4 정리

비동기 처리에서 공유 객체를 다루는 방법을 간단히 정리

- 비동기 처리시에는 메모리와 캐시 그리고 원자성을 고려해야한다.
- 비동기 처리시에는 불변 객체를 기본으로 한다.
- 가변객체를 쓸 경우에는 메모리 캐시, 원자성 문제를 해결해야한다.
- volatile 메모리에 값이 업데이트되어 최신 값을 유지하지만 원자성은 보장 못한다.
- 원자성을 보장하려면  java.util.concurrent.atomic 패키지 활용하면 된다. (atomicInteger)
- 여러개의 필드를 가지고 있는 객체일 경우 일관성을 유지하기 위해 synchronized블록을 활용한다.
- synchronized 사용시 과도한 사용은 자제하며 교착상태를 조심한다.



